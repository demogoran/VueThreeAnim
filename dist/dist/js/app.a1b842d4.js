(function(e){function t(t){for(var r,o,s=t[0],c=t[1],l=t[2],f=0,p=[];f<s.length;f++)o=s[f],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&p.push(i[o][0]),i[o]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(e[r]=c[r]);u&&u(t);while(p.length)p.shift()();return a.push.apply(a,l||[]),n()}function n(){for(var e,t=0;t<a.length;t++){for(var n=a[t],r=!0,s=1;s<n.length;s++){var c=n[s];0!==i[c]&&(r=!1)}r&&(a.splice(t--,1),e=o(o.s=n[0]))}return e}var r={},i={app:0},a=[];function o(t){if(r[t])return r[t].exports;var n=r[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=e,o.c=r,o.d=function(e,t,n){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)o.d(n,r,function(t){return e[t]}.bind(null,r));return n},o.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=t,s=s.slice();for(var l=0;l<s.length;l++)t(s[l]);var u=c;a.push([0,"chunk-vendors"]),n()})({0:function(e,t,n){e.exports=n("91f2")},"8fc7":function(e,t,n){},bcd5:function(e,t,n){"use strict";var r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{attrs:{id:"app"}})},i=[],a=(n("92a8"),n("5a89"));a.EffectComposer=function(e,t){if(this.renderer=e,void 0===t){var n={minFilter:a.LinearFilter,magFilter:a.LinearFilter,format:a.RGBAFormat,stencilBuffer:!1},r=e.getSize();t=new a.WebGLRenderTarget(r.width,r.height,n)}this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.passes=[],void 0===a.CopyShader&&console.error("THREE.EffectComposer relies on THREE.CopyShader"),this.copyPass=new a.ShaderPass(a.CopyShader)},Object.assign(a.EffectComposer.prototype,{swapBuffers:function(){var e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e},addPass:function(e){this.passes.push(e);var t=this.renderer.getSize();e.setSize(t.width,t.height)},insertPass:function(e,t){this.passes.splice(t,0,e)},render:function(e){var t,n,r=!1,i=this.passes.length;for(n=0;n<i;n++)if(t=this.passes[n],!1!==t.enabled){if(t.render(this.renderer,this.writeBuffer,this.readBuffer,e,r),t.needsSwap){if(r){var o=this.renderer.context;o.stencilFunc(o.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),o.stencilFunc(o.EQUAL,1,4294967295)}this.swapBuffers()}t instanceof a.MaskPass?r=!0:t instanceof a.ClearMaskPass&&(r=!1)}},reset:function(e){if(void 0===e){var t=this.renderer.getSize();e=this.renderTarget1.clone(),e.setSize(t.width,t.height)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2},setSize:function(e,t){this.renderTarget1.setSize(e,t),this.renderTarget2.setSize(e,t);for(var n=0;n<this.passes.length;n++)this.passes[n].setSize(e,t)}}),a.Pass=function(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1},Object.assign(a.Pass.prototype,{setSize:function(e,t){},render:function(e,t,n,r,i){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}),a.ShaderPass=function(e,t){a.Pass.call(this),this.textureID=void 0!==t?t:"tDiffuse",e instanceof a.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=a.UniformsUtils.clone(e.uniforms),this.material=new a.ShaderMaterial({defines:e.defines||{},uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.camera=new a.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new a.Scene,this.quad=new a.Mesh(new a.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)},a.ShaderPass.prototype=Object.assign(Object.create(a.Pass.prototype),{constructor:a.ShaderPass,render:function(e,t,n,r,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.quad.material=this.material,this.renderToScreen?e.render(this.scene,this.camera):e.render(this.scene,this.camera,t,this.clear)}}),a.RenderPass=function(e,t,n,r,i){a.Pass.call(this),this.scene=e,this.camera=t,this.overrideMaterial=n,this.clearColor=r,this.clearAlpha=void 0!==i?i:1,this.oldClearColor=new a.Color,this.oldClearAlpha=1,this.clear=!0,this.needsSwap=!1},a.RenderPass.prototype=Object.assign(Object.create(a.Pass.prototype),{constructor:a.RenderPass,render:function(e,t,n,r,i){this.scene.overrideMaterial=this.overrideMaterial,this.clearColor&&(this.oldClearColor.copy(e.getClearColor()),this.oldClearAlpha=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),e.render(this.scene,this.camera,n,this.clear),this.clearColor&&e.setClearColor(this.oldClearColor,this.oldClearAlpha),this.scene.overrideMaterial=null}}),a.MaskPass=function(e,t){a.Pass.call(this),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1},a.MaskPass.prototype=Object.assign(Object.create(a.Pass.prototype),{constructor:a.MaskPass,render:function(e,t,n,r,i){var a,o,s=e.context,c=e.state;c.buffers.color.setMask(!1),c.buffers.depth.setMask(!1),c.buffers.color.setLocked(!0),c.buffers.depth.setLocked(!0),this.inverse?(a=0,o=1):(a=1,o=0),c.buffers.stencil.setTest(!0),c.buffers.stencil.setOp(s.REPLACE,s.REPLACE,s.REPLACE),c.buffers.stencil.setFunc(s.ALWAYS,a,4294967295),c.buffers.stencil.setClear(o),e.render(this.scene,this.camera,n,this.clear),e.render(this.scene,this.camera,t,this.clear),c.buffers.color.setLocked(!1),c.buffers.depth.setLocked(!1),c.buffers.stencil.setFunc(s.EQUAL,1,4294967295),c.buffers.stencil.setOp(s.KEEP,s.KEEP,s.KEEP)}}),a.ClearMaskPass=function(){a.Pass.call(this),this.needsSwap=!1},a.ClearMaskPass.prototype=Object.create(a.Pass.prototype),Object.assign(a.ClearMaskPass.prototype,{render:function(e,t,n,r,i){e.state.buffers.stencil.setTest(!1)}}),a.BloomPass=function(e,t,n,r){a.Pass.call(this),e=void 0!==e?e:1,t=void 0!==t?t:25,n=void 0!==n?n:4,r=void 0!==r?r:256;var i={minFilter:a.LinearFilter,magFilter:a.LinearFilter,format:a.RGBAFormat};this.renderTargetX=new a.WebGLRenderTarget(r,r,i),this.renderTargetY=new a.WebGLRenderTarget(r,r,i),void 0===a.CopyShader&&console.error("THREE.BloomPass relies on THREE.CopyShader");var o=a.CopyShader;this.copyUniforms=a.UniformsUtils.clone(o.uniforms),this.copyUniforms["opacity"].value=e,this.materialCopy=new a.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:o.vertexShader,fragmentShader:o.fragmentShader,blending:a.AdditiveBlending,transparent:!0}),void 0===a.ConvolutionShader&&console.error("THREE.BloomPass relies on THREE.ConvolutionShader");var s=a.ConvolutionShader;this.convolutionUniforms=a.UniformsUtils.clone(s.uniforms),this.convolutionUniforms["uImageIncrement"].value=a.BloomPass.blurX,this.convolutionUniforms["cKernel"].value=a.ConvolutionShader.buildKernel(n),this.materialConvolution=new a.ShaderMaterial({uniforms:this.convolutionUniforms,vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,defines:{KERNEL_SIZE_FLOAT:t.toFixed(1),KERNEL_SIZE_INT:t.toFixed(0)}}),this.needsSwap=!1,this.camera=new a.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new a.Scene,this.quad=new a.Mesh(new a.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)},a.BloomPass.prototype=Object.assign(Object.create(a.Pass.prototype),{constructor:a.BloomPass,render:function(e,t,n,r,i){i&&e.context.disable(e.context.STENCIL_TEST),this.quad.material=this.materialConvolution,this.convolutionUniforms["tDiffuse"].value=n.texture,this.convolutionUniforms["uImageIncrement"].value=a.BloomPass.blurX,e.render(this.scene,this.camera,this.renderTargetX,!0),this.convolutionUniforms["tDiffuse"].value=this.renderTargetX.texture,this.convolutionUniforms["uImageIncrement"].value=a.BloomPass.blurY,e.render(this.scene,this.camera,this.renderTargetY,!0),this.quad.material=this.materialCopy,this.copyUniforms["tDiffuse"].value=this.renderTargetY.texture,i&&e.context.enable(e.context.STENCIL_TEST),e.render(this.scene,this.camera,n,this.clear)}}),a.BloomPass.blurX=new a.Vector2(.001953125,0),a.BloomPass.blurY=new a.Vector2(0,.001953125),a.CopyShader={uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor = opacity * texel;","}"].join("\n")},a.ConvolutionShader={defines:{KERNEL_SIZE_FLOAT:"25.0",KERNEL_SIZE_INT:"25"},uniforms:{tDiffuse:{type:"t",value:null},uImageIncrement:{type:"v2",value:new a.Vector2(.001953125,0)},cKernel:{type:"fv1",value:[]}},vertexShader:["uniform vec2 uImageIncrement;","varying vec2 vUv;","void main() {","vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float cKernel[ KERNEL_SIZE_INT ];","uniform sampler2D tDiffuse;","uniform vec2 uImageIncrement;","varying vec2 vUv;","void main() {","vec2 imageCoord = vUv;","vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );","for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {","sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];","imageCoord += uImageIncrement;","}","gl_FragColor = sum;","}"].join("\n"),buildKernel:function(e){function t(e,t){return Math.exp(-e*e/(2*t*t))}var n,r,i,a,o=25,s=2*Math.ceil(3*e)+1;for(s>o&&(s=o),a=.5*(s-1),r=new Array(s),i=0,n=0;n<s;++n)r[n]=t(n-a,e),i+=r[n];for(n=0;n<s;++n)r[n]/=i;return r}};var o=a,s=n("75b2"),c=n("a6de"),l=n("cffa"),u=(n("31f5"),n("01b5"),n("1427"),n("9dd7"),n("7c0e"),n("5a89")),f=function(e,t){this.object=e,this.domElement=void 0!==t?t:document,this.enabled=!0,this.target=new u["Vector3"],this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!1,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:u["MOUSE"].LEFT,MIDDLE:u["MOUSE"].MIDDLE,RIGHT:u["MOUSE"].RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return l.phi},this.getAzimuthalAngle=function(){return l.theta},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(r),n.update(),s=o.NONE},this.update=function(){var t=new u["Vector3"],i=(new u["Quaternion"]).setFromUnitVectors(e.up,new u["Vector3"](0,1,0)),a=i.clone().inverse(),m=new u["Vector3"],v=new u["Quaternion"];return function(){var e=n.object.position;return t.copy(e).sub(n.target),t.applyQuaternion(i),l.setFromVector3(t),n.autoRotate&&s===o.NONE&&k(S()),l.theta+=f.theta,l.phi+=f.phi,l.theta=Math.max(n.minAzimuthAngle,Math.min(n.maxAzimuthAngle,l.theta)),l.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,l.phi)),l.makeSafe(),l.radius*=p,l.radius=Math.max(n.minDistance,Math.min(n.maxDistance,l.radius)),n.target.add(d),t.setFromSpherical(l),t.applyQuaternion(a),e.copy(n.target).add(t),n.object.lookAt(n.target),!0===n.enableDamping?(f.theta*=1-n.dampingFactor,f.phi*=1-n.dampingFactor,d.multiplyScalar(1-n.dampingFactor)):(f.set(0,0,0),d.set(0,0,0)),p=1,!!(h||m.distanceToSquared(n.object.position)>c||8*(1-v.dot(n.object.quaternion))>c)&&(n.dispatchEvent(r),m.copy(n.object.position),v.copy(n.object.quaternion),h=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",te,!1),n.domElement.removeEventListener("mousedown",Q,!1),n.domElement.removeEventListener("wheel",X,!1),n.domElement.removeEventListener("touchstart",J,!1),n.domElement.removeEventListener("touchend",ee,!1),n.domElement.removeEventListener("touchmove",$,!1),document.removeEventListener("mousemove",Z,!1),document.removeEventListener("mouseup",K,!1),window.removeEventListener("keydown",W,!1)};var n=this,r={type:"change"},i={type:"start"},a={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY_PAN:4},s=o.NONE,c=1e-6,l=new u["Spherical"],f=new u["Spherical"],p=1,d=new u["Vector3"],h=!1,m=new u["Vector2"],v=new u["Vector2"],g=new u["Vector2"],_=new u["Vector2"],b=new u["Vector2"],y=new u["Vector2"],x=new u["Vector2"],C=new u["Vector2"],P=new u["Vector2"];function S(){return 2*Math.PI/60/60*n.autoRotateSpeed}function E(){return Math.pow(.95,n.zoomSpeed)}function k(e){f.theta-=e}function O(e){f.phi-=e}var w=function(){var e=new u["Vector3"];return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),d.add(e)}}(),I=function(){var e=new u["Vector3"];return function(t,r){!0===n.screenSpacePanning?e.setFromMatrixColumn(r,1):(e.setFromMatrixColumn(r,0),e.crossVectors(n.object.up,e)),e.multiplyScalar(t),d.add(e)}}(),M=function(){var e=new u["Vector3"];return function(t,r){var i=n.domElement===document?n.domElement.body:n.domElement;if(n.object.isPerspectiveCamera){var a=n.object.position;e.copy(a).sub(n.target);var o=e.length();o*=Math.tan(n.object.fov/2*Math.PI/180),w(2*t*o/i.clientHeight,n.object.matrix),I(2*r*o/i.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(w(t*(n.object.right-n.object.left)/n.object.zoom/i.clientWidth,n.object.matrix),I(r*(n.object.top-n.object.bottom)/n.object.zoom/i.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function A(e){n.object.isPerspectiveCamera?p/=e:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*e)),n.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function L(e){n.object.isPerspectiveCamera?p*=e:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/e)),n.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function D(e){m.set(e.clientX,e.clientY)}function F(e){x.set(e.clientX,e.clientY)}function T(e){_.set(e.clientX,e.clientY)}function R(e){v.set(e.clientX,e.clientY),g.subVectors(v,m).multiplyScalar(n.rotateSpeed);var t=n.domElement===document?n.domElement.body:n.domElement;k(2*Math.PI*g.x/t.clientHeight),O(2*Math.PI*g.y/t.clientHeight),m.copy(v),n.update()}function j(e){C.set(e.clientX,e.clientY),P.subVectors(C,x),P.y>0?A(E()):P.y<0&&L(E()),x.copy(C),n.update()}function B(e){b.set(e.clientX,e.clientY),y.subVectors(b,_).multiplyScalar(n.panSpeed),M(y.x,y.y),_.copy(b),n.update()}function z(e){}function V(e){e.deltaY<0?L(E()):e.deltaY>0&&A(E()),n.update()}function U(e){switch(e.keyCode){case n.keys.UP:M(0,n.keyPanSpeed),n.update();break;case n.keys.BOTTOM:M(0,-n.keyPanSpeed),n.update();break;case n.keys.LEFT:M(n.keyPanSpeed,0),n.update();break;case n.keys.RIGHT:M(-n.keyPanSpeed,0),n.update();break}}function N(e){m.set(e.touches[0].pageX,e.touches[0].pageY)}function G(e){if(n.enableZoom){var t=e.touches[0].pageX-e.touches[1].pageX,r=e.touches[0].pageY-e.touches[1].pageY,i=Math.sqrt(t*t+r*r);x.set(0,i)}if(n.enablePan){var a=.5*(e.touches[0].pageX+e.touches[1].pageX),o=.5*(e.touches[0].pageY+e.touches[1].pageY);_.set(a,o)}}function q(e){v.set(e.touches[0].pageX,e.touches[0].pageY),g.subVectors(v,m).multiplyScalar(n.rotateSpeed);var t=n.domElement===document?n.domElement.body:n.domElement;k(2*Math.PI*g.x/t.clientHeight),O(2*Math.PI*g.y/t.clientHeight),m.copy(v),n.update()}function H(e){if(n.enableZoom){var t=e.touches[0].pageX-e.touches[1].pageX,r=e.touches[0].pageY-e.touches[1].pageY,i=Math.sqrt(t*t+r*r);C.set(0,i),P.set(0,Math.pow(C.y/x.y,n.zoomSpeed)),A(P.y),x.copy(C)}if(n.enablePan){var a=.5*(e.touches[0].pageX+e.touches[1].pageX),o=.5*(e.touches[0].pageY+e.touches[1].pageY);b.set(a,o),y.subVectors(b,_).multiplyScalar(n.panSpeed),M(y.x,y.y),_.copy(b)}n.update()}function Y(e){}function Q(e){if(!1!==n.enabled){switch(e.preventDefault(),e.button){case n.mouseButtons.LEFT:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enablePan)return;T(e),s=o.PAN}else{if(!1===n.enableRotate)return;D(e),s=o.ROTATE}break;case n.mouseButtons.MIDDLE:if(!1===n.enableZoom)return;F(e),s=o.DOLLY;break;case n.mouseButtons.RIGHT:if(!1===n.enablePan)return;T(e),s=o.PAN;break}s!==o.NONE&&(document.addEventListener("mousemove",Z,!1),document.addEventListener("mouseup",K,!1),n.dispatchEvent(i))}}function Z(e){if(!1!==n.enabled)switch(e.preventDefault(),s){case o.ROTATE:if(!1===n.enableRotate)return;R(e);break;case o.DOLLY:if(!1===n.enableZoom)return;j(e);break;case o.PAN:if(!1===n.enablePan)return;B(e);break}}function K(e){!1!==n.enabled&&(z(e),document.removeEventListener("mousemove",Z,!1),document.removeEventListener("mouseup",K,!1),n.dispatchEvent(a),s=o.NONE)}function X(e){!1===n.enabled||!1===n.enableZoom||s!==o.NONE&&s!==o.ROTATE||(e.preventDefault(),e.stopPropagation(),n.dispatchEvent(i),V(e),n.dispatchEvent(a))}function W(e){!1!==n.enabled&&!1!==n.enableKeys&&!1!==n.enablePan&&U(e)}function J(e){if(!1!==n.enabled){switch(e.preventDefault(),e.touches.length){case 1:if(!1===n.enableRotate)return;N(e),s=o.TOUCH_ROTATE;break;case 2:if(!1===n.enableZoom&&!1===n.enablePan)return;G(e),s=o.TOUCH_DOLLY_PAN;break;default:s=o.NONE}s!==o.NONE&&n.dispatchEvent(i)}}function $(e){if(!1!==n.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:if(!1===n.enableRotate)return;if(s!==o.TOUCH_ROTATE)return;q(e);break;case 2:if(!1===n.enableZoom&&!1===n.enablePan)return;if(s!==o.TOUCH_DOLLY_PAN)return;H(e);break;default:s=o.NONE}}function ee(e){!1!==n.enabled&&(Y(e),n.dispatchEvent(a),s=o.NONE)}function te(e){!1!==n.enabled&&e.preventDefault()}n.domElement.addEventListener("contextmenu",te,!1),n.domElement.addEventListener("mousedown",Q,!1),n.domElement.addEventListener("wheel",X,!1),n.domElement.addEventListener("touchstart",J,!1),n.domElement.addEventListener("touchend",ee,!1),n.domElement.addEventListener("touchmove",$,!1),window.addEventListener("keydown",W,!1),this.update()};f.prototype=Object.create(u["EventDispatcher"].prototype),f.prototype.constructor=f,Object.defineProperties(f.prototype,{center:{get:function(){return console.warn("OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(e){console.warn("OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!e}},noRotate:{get:function(){return console.warn("OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(e){console.warn("OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!e}},noPan:{get:function(){return console.warn("OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(e){console.warn("OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!e}},noKeys:{get:function(){return console.warn("OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(e){console.warn("OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!e}},staticMoving:{get:function(){return console.warn("OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(e){console.warn("OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!e}},dynamicDampingFactor:{get:function(){return console.warn("OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(e){console.warn("OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=e}}});var p=f;function d(e){var t=this;e=Object.assign({container:"#app",fov:60,zNear:1,zFar:1e4,createCameraControls:!0,autoStart:!0,pixelRatio:window.devicePixelRatio,antialias:1===window.devicePixelRatio,alpha:!1},e),this.updateCallbacks=[],this.resizeCallbacks=[],this.objects={},this.renderer=new o.WebGLRenderer({antialias:e.antialias,alpha:e.alpha}),this.renderer.setPixelRatio(e.pixelRatio),this.container=document.body,document.body.appendChild(this.renderer.domElement);var n=this.container.clientWidth,r=this.container.clientHeight;this.camera=new o.PerspectiveCamera(e.fov,n/r,e.zNear,e.zFar),this.scene=new o.Scene,this.resize=this.resize.bind(this),setTimeout((function(){return t.resize()}),1),window.addEventListener("resize",this.resize,!1),this.tick=this.tick.bind(this),e.autoStart&&this.tick(),e.createCameraControls&&this.createOrbitControls()}d.prototype={createOrbitControls:function(){this.controls=new p(this.camera,this.renderer.domElement),this.addUpdateCallback(this.controls.update.bind(this.controls))},start:function(){this.tick()},addUpdateCallback:function(e){this.updateCallbacks.push(e)},addResizeCallback:function(e){this.resizeCallbacks.push(e)},add:function(e,t){t&&(this.objects[t]=e),this.scene.add(e)},addTo:function(e,t,n){n&&(this.objects[n]=e),this.get(t).add(e)},get:function(e){return this.objects[e]},remove:function(e){var t;t="string"===typeof e?this.objects[e]:e,t&&(t.parent.remove(t),delete this.objects[e])},tick:function(){this.update(),this.render(),requestAnimationFrame(this.tick)},update:function(){this.updateCallbacks.forEach((function(e){e()}))},render:function(){this.renderer.render(this.scene,this.camera)},resize:function(){var e=this.container.clientWidth,t=this.container.clientHeight;this.camera.aspect=e/t,this.camera.updateProjectionMatrix(),this.renderer.setSize(e,t),this.resizeCallbacks.forEach((function(e){e()}))},initPostProcessing:function(e){var t=this.renderer.getSize(this.renderer),n=this.renderer.getPixelRatio();t.width*=n,t.height*=n;var r=this.composer=new o.EffectComposer(this.renderer,new o.WebGLRenderTarget(t.width,t.height,{minFilter:o.LinearFilter,magFilter:o.LinearFilter,format:o.RGBAFormat,stencilBuffer:!1})),i=new o.RenderPass(this.scene,this.camera);this.composer.addPass(i);for(var a=0;a<e.length;a++){var s=e[a];s.renderToScreen=a===e.length-1,this.composer.addPass(s)}this.renderer.autoClear=!1,this.render=function(){this.renderer.clear(),this.composer.render()}.bind(this),this.addResizeCallback(function(){var e=this.container.clientWidth,t=this.container.clientHeight;r.setSize(e*n,t*n)}.bind(this))}};var h=d,m=(n("5c01"),n("e0c3"),n("cae9"),n("390b"),n("f339")),v=(n("537f"),n("e8ae")),g=n("5b9e"),_=n("ce6b");n("8281"),n("51e0"),n("bf0d"),n("40eb"),n("66a8"),n("453f"),n("9ff0"),n("513d"),n("7b71");function b(e,t){u["ShaderMaterial"].call(this);var n=e.uniformValues;if(delete e.uniformValues,this.setValues(e),this.uniforms=u["UniformsUtils"].merge([t,this.uniforms]),this.setUniformValues(n),n&&(n.map&&(this.defines["USE_MAP"]=""),n.normalMap&&(this.defines["USE_NORMALMAP"]=""),n.envMap&&(this.defines["USE_ENVMAP"]=""),n.aoMap&&(this.defines["USE_AOMAP"]=""),n.specularMap&&(this.defines["USE_SPECULARMAP"]=""),n.alphaMap&&(this.defines["USE_ALPHAMAP"]=""),n.lightMap&&(this.defines["USE_LIGHTMAP"]=""),n.emissiveMap&&(this.defines["USE_EMISSIVEMAP"]=""),n.bumpMap&&(this.defines["USE_BUMPMAP"]=""),n.displacementMap&&(this.defines["USE_DISPLACEMENTMAP"]=""),n.roughnessMap&&(this.defines["USE_DISPLACEMENTMAP"]=""),n.roughnessMap&&(this.defines["USE_ROUGHNESSMAP"]=""),n.metalnessMap&&(this.defines["USE_METALNESSMAP"]=""),n.gradientMap&&(this.defines["USE_GRADIENTMAP"]=""),n.envMap)){this.defines["USE_ENVMAP"]="";var r="ENVMAP_TYPE_CUBE",i="ENVMAP_MODE_REFLECTION",a="ENVMAP_BLENDING_MULTIPLY";switch(n.envMap.mapping){case u["CubeReflectionMapping"]:case u["CubeRefractionMapping"]:r="ENVMAP_TYPE_CUBE";break;case u["CubeUVReflectionMapping"]:case u["CubeUVRefractionMapping"]:r="ENVMAP_TYPE_CUBE_UV";break;case u["EquirectangularReflectionMapping"]:case u["EquirectangularRefractionMapping"]:r="ENVMAP_TYPE_EQUIREC";break;case u["SphericalReflectionMapping"]:r="ENVMAP_TYPE_SPHERE";break}switch(n.envMap.mapping){case u["CubeRefractionMapping"]:case u["EquirectangularRefractionMapping"]:i="ENVMAP_MODE_REFRACTION";break}switch(n.combine){case u["MixOperation"]:a="ENVMAP_BLENDING_MIX";break;case u["AddOperation"]:a="ENVMAP_BLENDING_ADD";break;case u["MultiplyOperation"]:default:a="ENVMAP_BLENDING_MULTIPLY";break}this.defines[r]="",this.defines[a]="",this.defines[i]=""}}function y(e){this.varyingParameters=[],this.vertexParameters=[],this.vertexFunctions=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],b.call(this,e,u["ShaderLib"]["basic"].uniforms),this.lights=!1,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function x(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentEmissive=[],this.fragmentSpecular=[],b.call(this,e,u["ShaderLib"]["lambert"].uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function C(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentEmissive=[],this.fragmentSpecular=[],b.call(this,e,u["ShaderLib"]["phong"].uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function P(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentRoughness=[],this.fragmentMetalness=[],this.fragmentEmissive=[],b.call(this,e,u["ShaderLib"]["standard"].uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function S(e){e.defines||(e.defines={}),e.defines["TOON"]="",C.call(this,e)}function E(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexPosition=[],this.vertexColor=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentShape=[],b.call(this,e,u["ShaderLib"]["points"].uniforms),this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function k(e){this.depthPacking=u["RGBADepthPacking"],this.clipping=!0,this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexPosition=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],b.call(this,e),this.uniforms=u["UniformsUtils"].merge([u["ShaderLib"]["depth"].uniforms,this.uniforms]),this.vertexShader=this.concatVertexShader(),this.fragmentShader=u["ShaderLib"]["depth"].fragmentShader}function O(e){this.depthPacking=u["RGBADepthPacking"],this.clipping=!0,this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexPosition=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],b.call(this,e),this.uniforms=u["UniformsUtils"].merge([u["ShaderLib"]["distanceRGBA"].uniforms,this.uniforms]),this.vertexShader=this.concatVertexShader(),this.fragmentShader=u["ShaderLib"]["distanceRGBA"].fragmentShader}function w(e,t){u["BufferGeometry"].call(this),this.prefabGeometry=e,this.isPrefabBufferGeometry=e.isBufferGeometry,this.prefabCount=t,this.isPrefabBufferGeometry?this.prefabVertexCount=e.attributes.position.count:this.prefabVertexCount=e.vertices.length,this.bufferIndices(),this.bufferPositions()}function I(e,t){u["BufferGeometry"].call(this),Array.isArray(e)?this.prefabGeometries=e:this.prefabGeometries=[e],this.prefabGeometriesCount=this.prefabGeometries.length,this.prefabCount=t*this.prefabGeometriesCount,this.repeatCount=t,this.prefabVertexCounts=this.prefabGeometries.map((function(e){return e.isBufferGeometry?e.attributes.position.count:e.vertices.length})),this.repeatVertexCount=this.prefabVertexCounts.reduce((function(e,t){return e+t}),0),this.bufferIndices(),this.bufferPositions()}function M(e,t){!0===e.isGeometry&&console.error("InstancedPrefabBufferGeometry prefab must be a BufferGeometry."),u["InstancedBufferGeometry"].call(this),this.prefabGeometry=e,this.copy(e),this.maxInstancedCount=t,this.prefabCount=t}b.prototype=Object.assign(Object.create(u["ShaderMaterial"].prototype),{constructor:b,setUniformValues:function(e){var t=this;if(e){var n=Object.keys(e);n.forEach((function(n){n in t.uniforms&&(t.uniforms[n].value=e[n])}))}},stringifyChunk:function(e){var t=void 0;return t=this[e]?"string"===typeof this[e]?this[e]:this[e].join("\n"):"",t},toJSON:function(e){var t=u["Material"].prototype.toJSON.call(this,e);for(var n in t.uniforms={},this.uniforms){var r=this.uniforms[n],i=r.value;null===i||void 0===i?t.uniforms[n]={value:i}:i.isTexture?t.uniforms[n]={type:"t",value:i.toJSON(e).uuid}:i.isColor?t.uniforms[n]={type:"c",value:i.getHex()}:i.isVector2?t.uniforms[n]={type:"v2",value:i.toArray()}:i.isVector3?t.uniforms[n]={type:"v3",value:i.toArray()}:i.isVector4?t.uniforms[n]={type:"v4",value:i.toArray()}:i.isMatrix4?t.uniforms[n]={type:"m4",value:i.toArray()}:t.uniforms[n]={value:i}}return Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t}}),y.prototype=Object.create(b.prototype),y.prototype.constructor=y,y.prototype.concatVertexShader=function(){return"\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n    #include <skinbase_vertex>\n  \n    #ifdef USE_ENVMAP\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n  \n    #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n    #include <envmap_vertex>\n    #include <fog_vertex>\n  }"},y.prototype.concatFragmentShader=function(){return"\n  uniform vec3 diffuse;\n  uniform float opacity;\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n\n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n    \n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n    \n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n  \n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  \n    // accumulation (baked indirect lighting only)\n    #ifdef USE_LIGHTMAP\n  \n      reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n  \n    #else\n  \n      reflectedLight.indirectDiffuse += vec3( 1.0 );\n  \n    #endif\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n  \n    vec3 outgoingLight = reflectedLight.indirectDiffuse;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <premultiplied_alpha_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n  }"},x.prototype=Object.create(b.prototype),x.prototype.constructor=x,x.prototype.concatVertexShader=function(){return"\n  #define LAMBERT\n\n  varying vec3 vLightFront;\n  \n  #ifdef DOUBLE_SIDED\n  \n    varying vec3 vLightBack;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <bsdfs>\n  #include <lights_pars_begin>\n  #include <envmap_physical_pars_fragment>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n    \n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <lights_lambert_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},x.prototype.concatFragmentShader=function(){return"\n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform float opacity;\n  \n  varying vec3 vLightFront;\n  \n  #ifdef DOUBLE_SIDED\n  \n    varying vec3 vLightBack;\n  \n  #endif\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <bsdfs>\n  #include <lights_pars_begin>\n  #include <envmap_physical_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <shadowmask_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n\t\n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n\n    "+this.stringifyChunk("fragmentEmissive")+"\n\n    #include <emissivemap_fragment>\n  \n    // accumulation\n    reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n  \n    #include <lightmap_fragment>\n  \n    reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n  \n    #ifdef DOUBLE_SIDED\n  \n      reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n  \n    #else\n  \n      reflectedLight.directDiffuse = vLightFront;\n  \n    #endif\n  \n    reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  }"},C.prototype=Object.create(b.prototype),C.prototype.constructor=C,C.prototype.concatVertexShader=function(){return"\n  #define PHONG\n\n  varying vec3 vViewPosition;\n\n  #ifndef FLAT_SHADED\n\n    varying vec3 vNormal;\n\n  #endif\n\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n\n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n\n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n\n    #include <beginnormal_vertex>\n\n    "+this.stringifyChunk("vertexNormal")+"\n\n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n    vNormal = normalize( transformedNormal );\n\n  #endif\n\n    #include <begin_vertex>\n\n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n\n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n\n    vViewPosition = - mvPosition.xyz;\n\n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},C.prototype.concatFragmentShader=function(){return"\n  #define PHONG\n\n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform vec3 specular;\n  uniform float shininess;\n  uniform float opacity;\n\n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <gradientmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <bsdfs>\n  #include <lights_pars_begin>\n  #include <envmap_physical_pars_fragment>\n  #include <lights_phong_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <bumpmap_pars_fragment>\n  #include <normalmap_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n\n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n\n  void main() {\n\n    "+this.stringifyChunk("fragmentInit")+"\n\n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n\n    "+this.stringifyChunk("fragmentDiffuse")+"\n\n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n\n    "+this.stringifyChunk("fragmentEmissive")+"\n\n    #include <emissivemap_fragment>\n\n    // accumulation\n    #include <lights_phong_fragment>\n    "+this.stringifyChunk("fragmentSpecular")+"\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n\n    // modulation\n    #include <aomap_fragment>\n\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n    #include <envmap_fragment>\n\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n\n  }"},P.prototype=Object.create(b.prototype),P.prototype.constructor=P,P.prototype.concatVertexShader=function(){return"\n  #define PHYSICAL\n\n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n  \n    vNormal = normalize( transformedNormal );\n  \n  #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n    \n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    vViewPosition = - mvPosition.xyz;\n  \n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},P.prototype.concatFragmentShader=function(){return"\n  #define PHYSICAL\n  \n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform float roughness;\n  uniform float metalness;\n  uniform float opacity;\n  \n  #ifndef STANDARD\n    uniform float clearCoat;\n    uniform float clearCoatRoughness;\n  #endif\n  \n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <bsdfs>\n  #include <cube_uv_reflection_fragment>\n  #include <lights_pars_begin>\n  #include <envmap_physical_pars_fragment>\n  #include <lights_physical_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <bumpmap_pars_fragment>\n  #include <normalmap_pars_fragment>\n  #include <roughnessmap_pars_fragment>\n  #include <metalnessmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n  \n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n  \n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    \n    float roughnessFactor = roughness;\n    "+this.stringifyChunk("fragmentRoughness")+"\n    #ifdef USE_ROUGHNESSMAP\n    \n      vec4 texelRoughness = texture2D( roughnessMap, vUv );\n    \n      // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n      roughnessFactor *= texelRoughness.g;\n    \n    #endif\n    \n    float metalnessFactor = metalness;\n    "+this.stringifyChunk("fragmentMetalness")+"\n    #ifdef USE_METALNESSMAP\n    \n      vec4 texelMetalness = texture2D( metalnessMap, vUv );\n      metalnessFactor *= texelMetalness.b;\n    \n    #endif\n    \n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    \n    "+this.stringifyChunk("fragmentEmissive")+"\n    \n    #include <emissivemap_fragment>\n  \n    // accumulation\n    #include <lights_physical_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  \n  }"},S.prototype=Object.create(C.prototype),S.prototype.constructor=S,E.prototype=Object.create(b.prototype),E.prototype.constructor=E,E.prototype.concatVertexShader=function(){return"\n  uniform float size;\n  uniform float scale;\n  \n  #include <common>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <color_vertex>\n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <project_vertex>\n  \n    #ifdef USE_SIZEATTENUATION\n      gl_PointSize = size * ( scale / - mvPosition.z );\n    #else\n      gl_PointSize = size;\n    #endif\n  \n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},E.prototype.concatFragmentShader=function(){return"\n  uniform vec3 diffuse;\n  uniform float opacity;\n  \n  #include <common>\n  #include <packing>\n  #include <color_pars_fragment>\n  #include <map_particle_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n  \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n  \n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_particle_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphatest_fragment>\n  \n    outgoingLight = diffuseColor.rgb;\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n    "+this.stringifyChunk("fragmentShape")+"\n  \n    #include <premultiplied_alpha_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n  }"},k.prototype=Object.create(b.prototype),k.prototype.constructor=k,k.prototype.concatVertexShader=function(){return"\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n  \n    #include <skinbase_vertex>\n  \n    #ifdef USE_DISPLACEMENTMAP\n  \n      #include <beginnormal_vertex>\n      #include <morphnormal_vertex>\n      #include <skinnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n\n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n    \n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  }"},O.prototype=Object.create(b.prototype),O.prototype.constructor=O,O.prototype.concatVertexShader=function(){return"\n  #define DISTANCE\n\n  varying vec3 vWorldPosition;\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n  \n    #include <skinbase_vertex>\n  \n    #ifdef USE_DISPLACEMENTMAP\n  \n      #include <beginnormal_vertex>\n      #include <morphnormal_vertex>\n      #include <skinnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n\n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n    \n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n  \n    vWorldPosition = worldPosition.xyz;\n  \n  }"},w.prototype=Object.create(u["BufferGeometry"].prototype),w.prototype.constructor=w,w.prototype.bufferIndices=function(){var e=[],t=void 0;if(this.isPrefabBufferGeometry)if(this.prefabGeometry.index)t=this.prefabGeometry.index.count,e=this.prefabGeometry.index.array;else{t=this.prefabVertexCount;for(var n=0;n<t;n++)e.push(n)}else{var r=this.prefabGeometry.faces.length;t=3*r;for(var i=0;i<r;i++){var a=this.prefabGeometry.faces[i];e.push(a.a,a.b,a.c)}}var o=new Uint32Array(this.prefabCount*t);this.setIndex(new u["BufferAttribute"](o,1));for(var s=0;s<this.prefabCount;s++)for(var c=0;c<t;c++)o[s*t+c]=e[c]+s*this.prefabVertexCount},w.prototype.bufferPositions=function(){var e=this.createAttribute("position",3).array;if(this.isPrefabBufferGeometry)for(var t=this.prefabGeometry.attributes.position.array,n=0,r=0;n<this.prefabCount;n++)for(var i=0;i<this.prefabVertexCount;i++,r+=3)e[r]=t[3*i],e[r+1]=t[3*i+1],e[r+2]=t[3*i+2];else for(var a=0,o=0;a<this.prefabCount;a++)for(var s=0;s<this.prefabVertexCount;s++,o+=3){var c=this.prefabGeometry.vertices[s];e[o]=c.x,e[o+1]=c.y,e[o+2]=c.z}},w.prototype.bufferUvs=function(){var e=this.createAttribute("uv",2).array;if(this.isPrefabBufferGeometry)for(var t=this.prefabGeometry.attributes.uv.array,n=0,r=0;n<this.prefabCount;n++)for(var i=0;i<this.prefabVertexCount;i++,r+=2)e[r]=t[2*i],e[r+1]=t[2*i+1];else{for(var a=this.prefabGeometry.faces.length,o=[],s=0;s<a;s++){var c=this.prefabGeometry.faces[s],l=this.prefabGeometry.faceVertexUvs[0][s];o[c.a]=l[0],o[c.b]=l[1],o[c.c]=l[2]}for(var u=0,f=0;u<this.prefabCount;u++)for(var p=0;p<this.prefabVertexCount;p++,f+=2){var d=o[p];e[f]=d.x,e[f+1]=d.y}}},w.prototype.createAttribute=function(e,t,n){var r=new Float32Array(this.prefabCount*this.prefabVertexCount*t),i=new u["BufferAttribute"](r,t);if(this.addAttribute(e,i),n)for(var a=[],o=0;o<this.prefabCount;o++)n(a,o,this.prefabCount),this.setPrefabData(i,o,a);return i},w.prototype.setPrefabData=function(e,t,n){e="string"===typeof e?this.attributes[e]:e;for(var r=t*this.prefabVertexCount*e.itemSize,i=0;i<this.prefabVertexCount;i++)for(var a=0;a<e.itemSize;a++)e.array[r++]=n[a]},I.prototype=Object.create(u["BufferGeometry"].prototype),I.prototype.constructor=I,I.prototype.bufferIndices=function(){var e=0;this.prefabIndices=this.prefabGeometries.map((function(t){var n=[];if(t.isBufferGeometry)if(t.index)n=t.index.array;else for(var r=0;r<t.attributes.position.count;r++)n.push(r);else for(var i=0;i<t.faces.length;i++){var a=t.faces[i];n.push(a.a,a.b,a.c)}return e+=n.length,n}));for(var t=new Uint32Array(e*this.repeatCount),n=0,r=0,i=0;i<this.prefabCount;i++){for(var a=i%this.prefabGeometriesCount,o=this.prefabIndices[a],s=this.prefabVertexCounts[a],c=0;c<o.length;c++)t[n++]=o[c]+r;r+=s}this.setIndex(new u["BufferAttribute"](t,1))},I.prototype.bufferPositions=function(){for(var e=this,t=this.createAttribute("position",3).array,n=this.prefabGeometries.map((function(t,n){var r=void 0;if(t.isBufferGeometry)r=t.attributes.position.array;else{var i=e.prefabVertexCounts[n];r=[];for(var a=0,o=0;a<i;a++){var s=t.vertices[a];r[o++]=s.x,r[o++]=s.y,r[o++]=s.z}}return r})),r=0,i=0;r<this.prefabCount;r++)for(var a=r%this.prefabGeometries.length,o=this.prefabVertexCounts[a],s=n[a],c=0;c<o;c++)t[i++]=s[3*c],t[i++]=s[3*c+1],t[i++]=s[3*c+2]},I.prototype.bufferUvs=function(){for(var e=this,t=this.createAttribute("uv",2).array,n=this.prefabGeometries.map((function(t,n){var r=void 0;if(t.isBufferGeometry)t.attributes.uv||console.error("No UV found in prefab geometry",t),r=t.attributes.uv.array;else{for(var i=e.prefabIndices[n].length/3,a=[],o=0;o<i;o++){var s=t.faces[o],c=t.faceVertexUvs[0][o];a[s.a]=c[0],a[s.b]=c[1],a[s.c]=c[2]}r=[];for(var l=0;l<a.length;l++)r[2*l]=a[l].x,r[2*l+1]=a[l].y}return r})),r=0,i=0;r<this.prefabCount;r++)for(var a=r%this.prefabGeometries.length,o=this.prefabVertexCounts[a],s=n[a],c=0;c<o;c++)t[i++]=s[2*c],t[i++]=s[2*c+1]},I.prototype.createAttribute=function(e,t,n){var r=new Float32Array(this.repeatCount*this.repeatVertexCount*t),i=new u["BufferAttribute"](r,t);if(this.addAttribute(e,i),n)for(var a=[],o=0;o<this.prefabCount;o++)n(a,o,this.prefabCount),this.setPrefabData(i,o,a);return i},I.prototype.setPrefabData=function(e,t,n){e="string"===typeof e?this.attributes[e]:e;var r=t%this.prefabGeometriesCount,i=this.prefabVertexCounts[r],a=(t/this.prefabGeometriesCount|0)*this.prefabGeometriesCount,o=a*this.repeatVertexCount,s=t-a,c=0,l=0;while(l<s)c+=this.prefabVertexCounts[l++];for(var u=(o+c)*e.itemSize,f=0;f<i;f++)for(var p=0;p<e.itemSize;p++)e.array[u++]=n[p]},M.prototype=Object.create(u["InstancedBufferGeometry"].prototype),M.prototype.constructor=M,M.prototype.createAttribute=function(e,t,n){var r=new Float32Array(this.prefabCount*t),i=new u["InstancedBufferAttribute"](r,t);if(this.addAttribute(e,i),n)for(var a=[],o=0;o<this.prefabCount;o++)n(a,o,this.prefabCount),this.setPrefabData(i,o,a);return i},M.prototype.setPrefabData=function(e,t,n){e="string"===typeof e?this.attributes[e]:e;for(var r=t*e.itemSize,i=0;i<e.itemSize;i++)e.array[r++]=n[i]};var A={separateFaces:function(e){for(var t=[],n=0,r=e.faces.length;n<r;n++){var i=t.length,a=e.faces[n],o=a.a,s=a.b,c=a.c,l=e.vertices[o],u=e.vertices[s],f=e.vertices[c];t.push(l.clone()),t.push(u.clone()),t.push(f.clone()),a.a=i,a.b=i+1,a.c=i+2}e.vertices=t},computeCentroid:function(e,t,n){var r=e.vertices[t.a],i=e.vertices[t.b],a=e.vertices[t.c];return n=n||new u["Vector3"],n.x=(r.x+i.x+a.x)/3,n.y=(r.y+i.y+a.y)/3,n.z=(r.z+i.z+a.z)/3,n},randomInBox:function(e,t){return t=t||new u["Vector3"],t.x=u["Math"].randFloat(e.min.x,e.max.x),t.y=u["Math"].randFloat(e.min.y,e.max.y),t.z=u["Math"].randFloat(e.min.z,e.max.z),t},randomAxis:function(e){return e=e||new u["Vector3"],e.x=u["Math"].randFloatSpread(2),e.y=u["Math"].randFloatSpread(2),e.z=u["Math"].randFloatSpread(2),e.normalize(),e},createDepthAnimationMaterial:function(e){return new k({uniforms:e.uniforms,defines:e.defines,vertexFunctions:e.vertexFunctions,vertexParameters:e.vertexParameters,vertexInit:e.vertexInit,vertexPosition:e.vertexPosition})},createDistanceAnimationMaterial:function(e){return new O({uniforms:e.uniforms,defines:e.defines,vertexFunctions:e.vertexFunctions,vertexParameters:e.vertexParameters,vertexInit:e.vertexInit,vertexPosition:e.vertexPosition})}};function L(e,t){u["BufferGeometry"].call(this),this.modelGeometry=e,this.faceCount=this.modelGeometry.faces.length,this.vertexCount=this.modelGeometry.vertices.length,t=t||{},t.computeCentroids&&this.computeCentroids(),this.bufferIndices(),this.bufferPositions(t.localizeFaces)}function D(e){u["BufferGeometry"].call(this),this.pointCount=e,this.bufferPositions()}L.prototype=Object.create(u["BufferGeometry"].prototype),L.prototype.constructor=L,L.prototype.computeCentroids=function(){this.centroids=[];for(var e=0;e<this.faceCount;e++)this.centroids[e]=A.computeCentroid(this.modelGeometry,this.modelGeometry.faces[e])},L.prototype.bufferIndices=function(){var e=new Uint32Array(3*this.faceCount);this.setIndex(new u["BufferAttribute"](e,1));for(var t=0,n=0;t<this.faceCount;t++,n+=3){var r=this.modelGeometry.faces[t];e[n]=r.a,e[n+1]=r.b,e[n+2]=r.c}},L.prototype.bufferPositions=function(e){var t=this.createAttribute("position",3).array,n=void 0,r=void 0;if(!0===e)for(n=0;n<this.faceCount;n++){var i=this.modelGeometry.faces[n],a=this.centroids?this.centroids[n]:A.computeCentroid(this.modelGeometry,i),o=this.modelGeometry.vertices[i.a],s=this.modelGeometry.vertices[i.b],c=this.modelGeometry.vertices[i.c];t[3*i.a]=o.x-a.x,t[3*i.a+1]=o.y-a.y,t[3*i.a+2]=o.z-a.z,t[3*i.b]=s.x-a.x,t[3*i.b+1]=s.y-a.y,t[3*i.b+2]=s.z-a.z,t[3*i.c]=c.x-a.x,t[3*i.c+1]=c.y-a.y,t[3*i.c+2]=c.z-a.z}else for(n=0,r=0;n<this.vertexCount;n++,r+=3){var l=this.modelGeometry.vertices[n];t[r]=l.x,t[r+1]=l.y,t[r+2]=l.z}},L.prototype.bufferUvs=function(){for(var e=this.createAttribute("uv",2).array,t=0;t<this.faceCount;t++){var n=this.modelGeometry.faces[t],r=void 0;r=this.modelGeometry.faceVertexUvs[0][t][0],e[2*n.a]=r.x,e[2*n.a+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][t][1],e[2*n.b]=r.x,e[2*n.b+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][t][2],e[2*n.c]=r.x,e[2*n.c+1]=r.y}},L.prototype.bufferSkinning=function(){for(var e=this.createAttribute("skinIndex",4).array,t=this.createAttribute("skinWeight",4).array,n=0;n<this.vertexCount;n++){var r=this.modelGeometry.skinIndices[n],i=this.modelGeometry.skinWeights[n];e[4*n]=r.x,e[4*n+1]=r.y,e[4*n+2]=r.z,e[4*n+3]=r.w,t[4*n]=i.x,t[4*n+1]=i.y,t[4*n+2]=i.z,t[4*n+3]=i.w}},L.prototype.createAttribute=function(e,t,n){var r=new Float32Array(this.vertexCount*t),i=new u["BufferAttribute"](r,t);if(this.addAttribute(e,i),n)for(var a=[],o=0;o<this.faceCount;o++)n(a,o,this.faceCount),this.setFaceData(i,o,a);return i},L.prototype.setFaceData=function(e,t,n){e="string"===typeof e?this.attributes[e]:e;for(var r=3*t*e.itemSize,i=0;i<3;i++)for(var a=0;a<e.itemSize;a++)e.array[r++]=n[a]},D.prototype=Object.create(u["BufferGeometry"].prototype),D.prototype.constructor=D,D.prototype.bufferPositions=function(){this.createAttribute("position",3)},D.prototype.createAttribute=function(e,t,n){var r=new Float32Array(this.pointCount*t),i=new u["BufferAttribute"](r,t);if(this.addAttribute(e,i),n)for(var a=[],o=0;o<this.pointCount;o++)n(a,o,this.pointCount),this.setPointData(i,o,a);return i},D.prototype.setPointData=function(e,t,n){e="string"===typeof e?this.attributes[e]:e;for(var r=t*e.itemSize,i=0;i<e.itemSize;i++)e.array[r++]=n[i]};var F="vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\n    vec4 v0 = (p2 - p0) * c.x;\n    vec4 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\n    vec3 v0 = (p2 - p0) * c.x;\n    vec3 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\n    vec2 v0 = (p2 - p0) * c.x;\n    vec2 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\n    float v0 = (p2 - p0) * c.x;\n    float v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nivec4 getCatmullRomSplineIndices(float l, float p) {\n    float index = floor(p);\n    int i0 = int(max(0.0, index - 1.0));\n    int i1 = int(index);\n    int i2 = int(min(index + 1.0, l));\n    int i3 = int(min(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\n    float index = floor(p);\n    int i0 = int(index == 0.0 ? l : index - 1.0);\n    int i1 = int(index);\n    int i2 = int(mod(index + 1.0, l));\n    int i3 = int(mod(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\n",T="vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\n",R="float easeBackIn(float p, float amplitude) {\n    return p * p * ((amplitude + 1.0) * p - amplitude);\n}\nfloat easeBackIn(float p) {\n    return easeBackIn(p, 1.70158);\n}\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackIn(t / d, amplitude) * c;\n}\nfloat easeBackIn(float t, float b, float c, float d) {\n    return b + easeBackIn(t / d) * c;\n}\n",j="float easeBackInOut(float p, float amplitude) {\n    amplitude *= 1.525;\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\n}\nfloat easeBackInOut(float p) {\n    return easeBackInOut(p, 1.70158);\n}\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackInOut(t / d, amplitude) * c;\n}\nfloat easeBackInOut(float t, float b, float c, float d) {\n    return b + easeBackInOut(t / d) * c;\n}\n",B="float easeBackOut(float p, float amplitude) {\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\n}\nfloat easeBackOut(float p) {\n    return easeBackOut(p, 1.70158);\n}\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackOut(t / d, amplitude) * c;\n}\nfloat easeBackOut(float t, float b, float c, float d) {\n    return b + easeBackOut(t / d) * c;\n}\n",z="float easeBezier(float p, vec4 curve) {\n    float ip = 1.0 - p;\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\n}\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\n    return b + easeBezier(t / d, curve) * c;\n}\n",V="float easeBounceIn(float p) {\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\n        return 1.0 - (7.5625 * p * p);\n    } else if (p < 2.0 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\n    } else if (p < 2.5 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\n    }\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\n}\nfloat easeBounceIn(float t, float b, float c, float d) {\n    return b + easeBounceIn(t / d) * c;\n}\n",U="float easeBounceInOut(float p) {\n    bool invert = (p < 0.5);\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\n    if (p < 1.0 / 2.75) {\n        p = 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    } else {\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n    }\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\n}\nfloat easeBounceInOut(float t, float b, float c, float d) {\n    return b + easeBounceInOut(t / d) * c;\n}\n",N="float easeBounceOut(float p) {\n    if (p < 1.0 / 2.75) {\n        return 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    }\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n}\nfloat easeBounceOut(float t, float b, float c, float d) {\n    return b + easeBounceOut(t / d) * c;\n}\n",G="float easeCircIn(float p) {\n    return -(sqrt(1.0 - p * p) - 1.0);\n}\nfloat easeCircIn(float t, float b, float c, float d) {\n    return b + easeCircIn(t / d) * c;\n}\n",q="float easeCircInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\n}\nfloat easeCircInOut(float t, float b, float c, float d) {\n    return b + easeCircInOut(t / d) * c;\n}\n",H="float easeCircOut(float p) {\n  return sqrt(1.0 - (p = p - 1.0) * p);\n}\nfloat easeCircOut(float t, float b, float c, float d) {\n  return b + easeCircOut(t / d) * c;\n}\n",Y="float easeCubicIn(float t) {\n  return t * t * t;\n}\nfloat easeCubicIn(float t, float b, float c, float d) {\n  return b + easeCubicIn(t / d) * c;\n}\n",Q="float easeCubicInOut(float t) {\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\n}\nfloat easeCubicInOut(float t, float b, float c, float d) {\n  return b + easeCubicInOut(t / d) * c;\n}\n",Z="float easeCubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\nfloat easeCubicOut(float t, float b, float c, float d) {\n  return b + easeCubicOut(t / d) * c;\n}\n",K="float easeElasticIn(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\n}\nfloat easeElasticIn(float p) {\n    return easeElasticIn(p, 1.0, 0.3);\n}\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticIn(t / d, amplitude, period) * c;\n}\nfloat easeElasticIn(float t, float b, float c, float d) {\n    return b + easeElasticIn(t / d) * c;\n}\n",X="float easeElasticInOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\n}\nfloat easeElasticInOut(float p) {\n    return easeElasticInOut(p, 1.0, 0.3);\n}\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticInOut(float t, float b, float c, float d) {\n    return b + easeElasticInOut(t / d) * c;\n}\n",W="float easeElasticOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\n}\nfloat easeElasticOut(float p) {\n    return easeElasticOut(p, 1.0, 0.3);\n}\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticOut(float t, float b, float c, float d) {\n    return b + easeElasticOut(t / d) * c;\n}\n",J="float easeExpoIn(float p) {\n    return pow(2.0, 10.0 * (p - 1.0));\n}\nfloat easeExpoIn(float t, float b, float c, float d) {\n    return b + easeExpoIn(t / d) * c;\n}\n",$="float easeExpoInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\n}\nfloat easeExpoInOut(float t, float b, float c, float d) {\n    return b + easeExpoInOut(t / d) * c;\n}\n",ee="float easeExpoOut(float p) {\n  return 1.0 - pow(2.0, -10.0 * p);\n}\nfloat easeExpoOut(float t, float b, float c, float d) {\n  return b + easeExpoOut(t / d) * c;\n}\n",te="float easeQuadIn(float t) {\n    return t * t;\n}\nfloat easeQuadIn(float t, float b, float c, float d) {\n  return b + easeQuadIn(t / d) * c;\n}\n",ne="float easeQuadInOut(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\nfloat easeQuadInOut(float t, float b, float c, float d) {\n    return b + easeQuadInOut(t / d) * c;\n}\n",re="float easeQuadOut(float t) {\n  return -t * (t - 2.0);\n}\nfloat easeQuadOut(float t, float b, float c, float d) {\n  return b + easeQuadOut(t / d) * c;\n}\n",ie="float easeQuartIn(float t) {\n  return t * t * t * t;\n}\nfloat easeQuartIn(float t, float b, float c, float d) {\n  return b + easeQuartIn(t / d) * c;\n}\n",ae="float easeQuartInOut(float t) {\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\nfloat easeQuartInOut(float t, float b, float c, float d) {\n    return b + easeQuartInOut(t / d) * c;\n}\n",oe="float easeQuartOut(float t) {\n  return 1.0 - pow(1.0 - t, 4.0);\n}\nfloat easeQuartOut(float t, float b, float c, float d) {\n  return b + easeQuartOut(t / d) * c;\n}\n",se="float easeQuintIn(float t) {\n    return pow(t, 5.0);\n}\nfloat easeQuintIn(float t, float b, float c, float d) {\n    return b + easeQuintIn(t / d) * c;\n}\n",ce="float easeQuintInOut(float t) {\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\n}\nfloat easeQuintInOut(float t, float b, float c, float d) {\n    return b + easeQuintInOut(t / d) * c;\n}\n",le="float easeQuintOut(float t) {\n    return (t -= 1.0) * t * t * t * t + 1.0;\n}\nfloat easeQuintOut(float t, float b, float c, float d) {\n    return b + easeQuintOut(t / d) * c;\n}\n",ue="float easeSineIn(float p) {\n  return -cos(p * 1.57079632679) + 1.0;\n}\nfloat easeSineIn(float t, float b, float c, float d) {\n  return b + easeSineIn(t / d) * c;\n}\n",fe="float easeSineInOut(float p) {\n  return -0.5 * (cos(PI * p) - 1.0);\n}\nfloat easeSineInOut(float t, float b, float c, float d) {\n  return b + easeSineInOut(t / d) * c;\n}\n",pe="float easeSineOut(float p) {\n  return sin(p * 1.57079632679);\n}\nfloat easeSineOut(float t, float b, float c, float d) {\n  return b + easeSineOut(t / d) * c;\n}\n",de="vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\n}\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\n}",he="vec3 rotateVector(vec4 q, vec3 v) {\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    float halfAngle = angle * 0.5;\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\n}\n",me="vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\n    float s = 1.0 - t;\n    float c = dot(q0, q1);\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\n    if (sqrSn > 2.220446049250313e-16) {\n        float sn = sqrt(sqrSn);\n        float len = atan(sn, c * dir);\n        s = sin(s * len) / sn;\n        t = sin(t * len) / sn;\n    }\n    float tDir = t * dir;\n    return normalize(q0 * s + q1 * tDir);\n}\n",ve={catmull_rom_spline:F,cubic_bezier:T,ease_back_in:R,ease_back_in_out:j,ease_back_out:B,ease_bezier:z,ease_bounce_in:V,ease_bounce_in_out:U,ease_bounce_out:N,ease_circ_in:G,ease_circ_in_out:q,ease_circ_out:H,ease_cubic_in:Y,ease_cubic_in_out:Q,ease_cubic_out:Z,ease_elastic_in:K,ease_elastic_in_out:X,ease_elastic_out:W,ease_expo_in:J,ease_expo_in_out:$,ease_expo_out:ee,ease_quad_in:te,ease_quad_in_out:ne,ease_quad_out:re,ease_quart_in:ie,ease_quart_in_out:ae,ease_quart_out:oe,ease_quint_in:se,ease_quint_in_out:ce,ease_quint_out:le,ease_sine_in:ue,ease_sine_in_out:fe,ease_sine_out:pe,quadratic_bezier:de,quaternion_rotation:he,quaternion_slerp:me};function ge(e,t,n,r,i){this.key=e,this.start=t,this.duration=n,this.transition=r,this.compiler=i,this.trail=0}function _e(){this.duration=0,this.timeKey="tTime",this.segments={},this.__key=0}ge.prototype.compile=function(){return this.compiler(this)},Object.defineProperty(ge.prototype,"end",{get:function(){return this.start+this.duration}}),_e.segmentDefinitions={},_e.register=function(e,t){return _e.segmentDefinitions[e]=t,t},_e.prototype.add=function(e,t,n){var r=eval,i=this.duration;void 0!==n?("number"===typeof n?i=n:"string"===typeof n&&r("start"+n),this.duration=Math.max(this.duration,i+e)):this.duration+=e;for(var a=Object.keys(t),o=void 0,s=0;s<a.length;s++)o=a[s],this.processTransition(o,t[o],i,e)},_e.prototype.processTransition=function(e,t,n,r){var i=_e.segmentDefinitions[e],a=this.segments[e];a||(a=this.segments[e]=[]),void 0===t.from&&(0===a.length?t.from=i.defaultFrom:t.from=a[a.length-1].transition.to),a.push(new ge((this.__key++).toString(),n,r,t,i.compiler))},_e.prototype.compile=function(){for(var e=[],t=Object.keys(this.segments),n=void 0,r=0;r<t.length;r++)n=this.segments[t[r]],this.fillGaps(n),n.forEach((function(t){e.push(t.compile())}));return e},_e.prototype.fillGaps=function(e){if(0!==e.length){for(var t=void 0,n=void 0,r=0;r<e.length-1;r++)t=e[r],n=e[r+1],t.trail=n.start-t.end;t=e[e.length-1],t.trail=this.duration-t.end}},_e.prototype.getTransformCalls=function(e){var t=this.timeKey;return this.segments[e]?this.segments[e].map((function(e){return"applyTransform"+e.key+"("+t+", transformed);"})).join("\n"):""};var be={vec3:function(e,t,n){var r=(t.x||0).toPrecision(n),i=(t.y||0).toPrecision(n),a=(t.z||0).toPrecision(n);return"vec3 "+e+" = vec3("+r+", "+i+", "+a+");"},vec4:function(e,t,n){var r=(t.x||0).toPrecision(n),i=(t.y||0).toPrecision(n),a=(t.z||0).toPrecision(n),o=(t.w||0).toPrecision(n);return"vec4 "+e+" = vec4("+r+", "+i+", "+a+", "+o+");"},delayDuration:function(e){return"\n    float cDelay"+e.key+" = "+e.start.toPrecision(4)+";\n    float cDuration"+e.key+" = "+e.duration.toPrecision(4)+";\n    "},progress:function(e){return 0===e.duration?"float progress = 1.0;":"\n      float progress = clamp(time - cDelay"+e.key+", 0.0, cDuration"+e.key+") / cDuration"+e.key+";\n      "+(e.transition.ease?"progress = "+e.transition.ease+"(progress"+(e.transition.easeParams?", "+e.transition.easeParams.map((function(e){return e.toPrecision(4)})).join(", "):"")+");":"")+"\n      "},renderCheck:function(e){var t=e.start.toPrecision(4),n=(e.end+e.trail).toPrecision(4);return"if (time < "+t+" || time > "+n+") return;"}},ye={compiler:function(e){return"\n    "+be.delayDuration(e)+"\n    "+be.vec3("cTranslateFrom"+e.key,e.transition.from,2)+"\n    "+be.vec3("cTranslateTo"+e.key,e.transition.to,2)+"\n    \n    void applyTransform"+e.key+"(float time, inout vec3 v) {\n    \n      "+be.renderCheck(e)+"\n      "+be.progress(e)+"\n    \n      v += mix(cTranslateFrom"+e.key+", cTranslateTo"+e.key+", progress);\n    }\n    "},defaultFrom:new u["Vector3"](0,0,0)};_e.register("translate",ye);var xe={compiler:function(e){var t=e.transition.origin;return"\n    "+be.delayDuration(e)+"\n    "+be.vec3("cScaleFrom"+e.key,e.transition.from,2)+"\n    "+be.vec3("cScaleTo"+e.key,e.transition.to,2)+"\n    "+(t?be.vec3("cOrigin"+e.key,t,2):"")+"\n    \n    void applyTransform"+e.key+"(float time, inout vec3 v) {\n    \n      "+be.renderCheck(e)+"\n      "+be.progress(e)+"\n    \n      "+(t?"v -= cOrigin"+e.key+";":"")+"\n      v *= mix(cScaleFrom"+e.key+", cScaleTo"+e.key+", progress);\n      "+(t?"v += cOrigin"+e.key+";":"")+"\n    }\n    "},defaultFrom:new u["Vector3"](1,1,1)};_e.register("scale",xe);var Ce={compiler:function(e){var t=new u["Vector4"](e.transition.from.axis.x,e.transition.from.axis.y,e.transition.from.axis.z,e.transition.from.angle),n=e.transition.to.axis||e.transition.from.axis,r=new u["Vector4"](n.x,n.y,n.z,e.transition.to.angle),i=e.transition.origin;return"\n    "+be.delayDuration(e)+"\n    "+be.vec4("cRotationFrom"+e.key,t,8)+"\n    "+be.vec4("cRotationTo"+e.key,r,8)+"\n    "+(i?be.vec3("cOrigin"+e.key,i,2):"")+"\n    \n    void applyTransform"+e.key+"(float time, inout vec3 v) {\n      "+be.renderCheck(e)+"\n      "+be.progress(e)+"\n\n      "+(i?"v -= cOrigin"+e.key+";":"")+"\n      vec3 axis = normalize(mix(cRotationFrom"+e.key+".xyz, cRotationTo"+e.key+".xyz, progress));\n      float angle = mix(cRotationFrom"+e.key+".w, cRotationTo"+e.key+".w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      "+(i?"v += cOrigin"+e.key+";":"")+"\n    }\n    "},defaultFrom:{axis:new u["Vector3"],angle:0}};function Pe(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Se(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Pe(n,!0).forEach((function(t){Object(m["a"])(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Pe(n).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}_e.register("rotate",Ce);var Ee=function(e){function t(e,n){var r;Object(s["a"])(this,t);var i="in",a=(new o.Box3).setFromObject(new o.Mesh(n,new o.MeshNormalMaterial)),c=a.getSize().x+100,l=a.getSize().y;A.separateFaces(n);var u,f,p,d,h=new L(n,{localizeFaces:!0,computeCentroids:!0});h.bufferUvs();var m=h.createAttribute("aDelayDuration",2),_=.8,b=1.2,y=.9,x=.125,C=.11,S=b+y+x+C;for(u=0,p=0;u<h.faceCount;u++){d=h.centroids[u];var E,k=o.Math.randFloat(_,b),O=o.Math.mapLinear(d.x,.5*-c,.5*c,0,y);for(E="in"===i?o.Math.mapLinear(Math.abs(d.y),0,.5*l,0,x):o.Math.mapLinear(Math.abs(d.y),0,.5*l,x,0),f=0;f<3;f++)m.array[p]=O+E+Math.random()*C*k,m.array[p+1]=k,p+=2}h.createAttribute("aStartPosition",3,(function(e,t){h.centroids[t].toArray(e)})),h.createAttribute("aEndPosition",3,(function(e,t){h.centroids[t].toArray(e)}));var w=h.createAttribute("aControl0",3),I=h.createAttribute("aControl1",3),M=new o.Vector3,D=new o.Vector3,F=[];for(u=0,p=0;u<h.faceCount;u++){d=h.centroids[u];var T=Math.sign(d.y);M.x=-10*o.Math.randFloat(.1,.3),M.y=T*o.Math.randFloat(.1,.3)*0,M.z=o.Math.randFloatSpread(50),D.x=-10*o.Math.randFloat(.3,.6),D.y=-T*o.Math.randFloat(.3,.6)*0,D.z=o.Math.randFloatSpread(-50),"in"===i?(M.subVectors(d,M),D.subVectors(d,D)):(M.addVectors(d,M),D.addVectors(d,D)),h.setFaceData(w,u,M.toArray(F)),h.setFaceData(I,u,D.toArray(F))}var R=new o.Texture;R.minFilter=o.NearestFilter;var j=new P(Se({flatShading:!0,transparent:!0,uniforms:{uTime:{value:0},needSplash:1,textureImage:null},uniformValues:{map:R,needSplash:1,textureImage:(new o.TextureLoader).load("logo.svg"),canvasResolution:{x:window.innerWidth,y:window.innerHeight},metalness:.5,roughness:.5}},e));return r=Object(v["a"])(this,Object(g["a"])(t).call(this,h,j)),r.totalDuration=S,r.frustumCulled=!1,r}return Object(_["a"])(t,e),Object(c["a"])(t,[{key:"time",get:function(){return this.material.uniforms["uTime"].value},set:function(e){this.material.uniforms["uTime"].value=e}}]),t}(o.Mesh),ke=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object(s["a"])(this,e);var n=new h({fov:80,createCameraControls:!1});n.renderer.setClearColor("black"),n.camera.position.set(0,0,30);var r=new o.AmbientLight(16777215,4);n.scene.add(r),this.root=n,this.shaderOptions=t}return Object(c["a"])(e,[{key:"addAnimationMesh",value:function(e){var t=new Ee(this.shaderOptions,e);this.root.add(t);var n=7,r=new l["b"]({repeat:0});r.to(t,n,{time:t.totalDuration,repeat:0,yoyo:!0,ease:l["a"].easeIn,onComplete:function(){}})}}]),e}(),Oe={vertexFunctions:[ve["ease_cubic_in_out"],ve["ease_quad_out"],ve["ease_back_in"],ve["ease_elastic_in_out"],ve["quaternion_rotation"],ve["cubic_bezier"],ve["ease_out_cubic"]],vertexParameters:["uniform float uTime;","uniform vec3 midPoint;","uniform float needSplash;","attribute vec2 aDelayDuration;","attribute vec3 aStartPosition;","attribute vec3 aEndPosition;","attribute vec4 aAxisAngle;","attribute vec3 aControl0;","attribute vec3 aControl1;"],vertexInit:["float tProgress = clamp(uTime - aDelayDuration.x, 0.0, aDelayDuration.y) / aDelayDuration.y;"],vertexPosition:["transformed *= tProgress;","transformed += cubicBezier(aStartPosition, aControl0, aControl1, aEndPosition, tProgress);"],fragmentParameters:["vec3 vecDataF;","vec3 aStartPositionF;","uniform sampler2D textureImage;"],fragmentMap:["diffuseColor = texture2D(textureImage, vUv);"]},we=5,Ie=new ke(Oe);Ie.addAnimationMesh(new o.PlaneGeometry(8.571428571428571*we,we,300,300));var Me={},Ae=Me,Le=(n("e5cd"),n("ab80")),De=Object(Le["a"])(Ae,r,i,!1,null,null,null);t["a"]=De.exports},e5cd:function(e,t,n){"use strict";var r=n("8fc7"),i=n.n(r);i.a}});
//# sourceMappingURL=app.a1b842d4.js.map